/**
 * @file main.c
 * @brief Complete example using the redesigned STM32 Platform API
 * 
 * This example demonstrates a real-world vehicle control unit that:
 * - Receives pedal position via CAN
 * - Reads throttle position from ADC
 * - Sends motor commands via CAN
 * - Logs data via UART
 * - Controls cooling fan PWM
 */

#include "main.h"
#include "stm32_platform.h"

/* ==================== Hardware Handles (from CubeMX) ==================== */
CAN_HandleTypeDef hcan1;
UART_HandleTypeDef huart2;
ADC_HandleTypeDef hadc1;
TIM_HandleTypeDef htim2;

/* ==================== Application State ==================== */
typedef struct {
    uint8_t pedalPosition;      // 0-100%
    uint16_t throttleRaw;       // ADC raw value
    float throttleVoltage;      // 0-5V
    float motorSpeed;           // RPM
    bool systemReady;
} VehicleState_t;

VehicleState_t vehicle = {0};

/* ==================== CAN Message Handlers ==================== */

// Called automatically when CAN message 0x180 arrives
void onPedalMessage(CANMessage_t* msg) {
    vehicle.pedalPosition = msg->data[0];
    
    // Log to UART (instance 0)
    P_UART.printf(0, "Pedal: %d%%\n", vehicle.pedalPosition);
    
    // Update database
    Database.set("pedal.position", vehicle.pedalPosition);
}

// Called for CAN messages 0x200-0x20F (motor controller responses)
void onMotorResponse(CANMessage_t* msg) {
    // Parse motor speed from CAN data
    vehicle.motorSpeed = (msg->data[0] << 8) | msg->data[1];
    
    P_UART.printf(0, "Motor RPM: %.0f\n", vehicle.motorSpeed);
    
    // Adjust cooling fan based on speed (instance 0)
    if (vehicle.motorSpeed > 5000) {
        P_PWM.setDutyCycle(0, TIM_CHANNEL_1, 100.0);  // Fan 100%
    } else if (vehicle.motorSpeed > 3000) {
        P_PWM.setDutyCycle(0, TIM_CHANNEL_1, 60.0);   // Fan 60%
    } else {
        P_PWM.setDutyCycle(0, TIM_CHANNEL_1, 30.0);   // Fan 30%
    }
}

// Called when any unhandled CAN message arrives
void onUnknownCANMessage(CANMessage_t* msg) {
    P_UART.printf(0, "Unknown CAN ID: 0x%03X\n", msg->id);
}

/* ==================== Application Functions ==================== */

void sendMotorCommand(void) {
    // Read throttle position from ADC (instance 0)
    vehicle.throttleRaw = P_ADC.readRaw(0, ADC_CHANNEL_1);
    vehicle.throttleVoltage = P_ADC.readVoltage(0, ADC_CHANNEL_1);
    
    // Calculate motor command (0-100%)
    uint8_t motorCommand = (vehicle.throttleVoltage / 5.0) * 100;
    
    // Apply pedal position limit
    if (motorCommand > vehicle.pedalPosition) {
        motorCommand = vehicle.pedalPosition;
    }
    
    // Send motor command via CAN (instance 0)
    uint8_t data[8] = {
        motorCommand,           // Byte 0: Throttle command
        0x01,                   // Byte 1: Enable motor
        0x00, 0x00,            // Bytes 2-3: Reserved
        vehicle.pedalPosition,  // Byte 4: Pedal position
        0x00, 0x00, 0x00       // Bytes 5-7: Reserved
    };
    
    if (!P_CAN.send(0, 0x300, data, 8)) {
        P_UART.println(0, "ERROR: CAN send failed");
        
        // Check error details
        plt_status_t err = Platform.getLastError();
        P_UART.printf(0, "Error code: %d - %s\n", err, Platform.getErrorString(err));
    }
}

void systemHealthCheck(void) {
    // Check CAN bus status (instance 0)
    if (!P_CAN.isReady(0)) {
        P_UART.println(0, "WARNING: CAN bus not ready");
        vehicle.systemReady = false;
        return;
    }
    
    // Check if we've received recent messages
    if (P_CAN.availableMessages(0) == 0) {
        // No messages for a while - could add timeout tracking
    }
    
    // Check ADC readings are valid
    if (vehicle.throttleVoltage > 5.1) {
        P_UART.println(0, "WARNING: Throttle sensor out of range");
        vehicle.systemReady = false;
        return;
    }
    
    vehicle.systemReady = true;
}

void printSystemStatus(void) {
    P_UART.println(0, "========== System Status ==========");
    P_UART.printf(0, "Platform Version: %s\n", Platform.version());
    P_UART.printf(0, "System Ready: %s\n", vehicle.systemReady ? "YES" : "NO");
    P_UART.printf(0, "Pedal Position: %d%%\n", vehicle.pedalPosition);
    P_UART.printf(0, "Throttle ADC: %d (%.2fV)\n", vehicle.throttleRaw, vehicle.throttleVoltage);
    P_UART.printf(0, "Motor Speed: %.0f RPM\n", vehicle.motorSpeed);
    P_UART.printf(0, "CAN Messages: %d pending\n", P_CAN.availableMessages(0));
    P_UART.printf(0, "CAN Error Count: %d\n", P_CAN.getErrorCount(0));
    P_UART.println(0, "===================================\n");
}

/* ==================== Main Function ==================== */

int main(void) {
    /* MCU Configuration (generated by CubeMX) */
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_CAN1_Init();
    MX_USART2_UART_Init();
    MX_ADC1_Init();
    MX_TIM2_Init();
    
    /* ==================== Platform Initialization ==================== */
    
    // Initialize platform with all peripherals (v2.1.0 array-based)
    void* cans[] = {&hcan1};
    void* uarts[] = {&huart2};
    void* adcs[] = {&hadc1};
    void* tims[] = {&htim2};
    
    PlatformHandles_t handles = {
        .hcan = cans,
        .can_count = 1,
        .huart = uarts,
        .uart_count = 1,
        .hadc = adcs,
        .adc_count = 1,
        .htim = tims,
        .tim_count = 1
    };
    
    Platform.begin(&handles)
            ->onCAN(onUnknownCANMessage);  // Default CAN handler
    
    // Wait for platform ready
    HAL_Delay(100);
    
    /* ==================== Application Setup ==================== */
    
    // Configure UART for debugging
    P_UART.println(0, "\n\n===================================");
    P_UART.println(0, "Vehicle Control Unit v1.0.0");
    P_UART.printf(0, "Platform: %s\n", Platform.version());
    P_UART.println(0, "===================================\n");
    
    // Set up CAN message routing (instance 0)
    P_CAN.route(0, 0x180, onPedalMessage);           // Pedal position
    P_CAN.routeRange(0, 0x200, 0x20F, onMotorResponse);  // Motor responses
    
    // Configure CAN filters (optional - accept all by default)
    P_CAN.setFilter(0, 0x180, 0x7FF);  // Only accept pedal message
    
    // Configure ADC (instance 0)
    P_ADC.setResolution(0, 12);        // 12-bit resolution
    P_ADC.setReference(0, 3.3);        // 3.3V reference
    P_ADC.calibrate(0);                // Calibrate ADC
    
    // Configure PWM for cooling fan (instance 0)
    P_PWM.setFrequency(0, 25000);  // 25 kHz for fan
    P_PWM.start(0, TIM_CHANNEL_1);
    P_PWM.setDutyCycle(0, TIM_CHANNEL_1, 30.0);  // Start at 30%
    
    P_UART.println(0, "System initialized successfully\n");
    
    /* ==================== Main Loop ==================== */
    
    uint32_t lastCommandTime = 0;
    uint32_t lastStatusTime = 0;
    uint32_t lastHealthCheck = 0;
    
    while (1) {
        // Process all CAN messages (calls registered callbacks)
        P_CAN.handleRxMessages(0);
        
        // Send motor command every 50ms
        if (HAL_GetTick() - lastCommandTime >= 50) {
            lastCommandTime = HAL_GetTick();
            
            if (vehicle.systemReady) {
                sendMotorCommand();
            } else {
                // Safety: Send zero throttle if system not ready
                uint8_t safeData[8] = {0};
                P_CAN.send(0, 0x300, safeData, 8);
            }
        }
        
        // Print status every 1 second
        if (HAL_GetTick() - lastStatusTime >= 1000) {
            lastStatusTime = HAL_GetTick();
            printSystemStatus();
        }
        
        // Health check every 100ms
        if (HAL_GetTick() - lastHealthCheck >= 100) {
            lastHealthCheck = HAL_GetTick();
            systemHealthCheck();
        }
        
        // Optional: Process UART commands
        if (UART.available() > 0) {
            char cmd = UART.read();
            
            switch (cmd) {
                case 's':
                    printSystemStatus();
                    break;
                    
                case 'r':
                    P_UART.println("Resetting system...");
                    NVIC_SystemReset();
                    break;
                    
                case 'c':
                    P_UART.printf("CAN Stats:\n");
                    P_UART.printf("  TX Count: %d\n", P_CAN.getTxCount());
                    P_UART.printf("  RX Count: %d\n", P_CAN.getRxCount());
                    P_UART.printf("  Errors: %d\n", P_CAN.getErrorCount());
                    break;
                    
                default:
                    P_UART.println("Unknown command. Commands: s=status, r=reset, c=can stats");
            }
        }
    }
}

/* ==================== System Configuration (CubeMX Generated) ==================== */

void SystemClock_Config(void) {
    // CubeMX generated code
}

void Error_Handler(void) {
    P_UART.println("FATAL ERROR: System halted");
    P_UART.printf("Error: %s\n", STM32.getErrorString(STM32.getLastError()));
    
    while (1) {
        // Blink error LED
        HAL_Delay(200);
    }
}

/* ==================== Comparison: Same App with Old API ==================== */

#ifdef OLD_API_EXAMPLE
/* This is what the same application looked like with the old API: */

void main_old_api(void) {
    // Setup handlers (verbose)
    handler_set_t handlers = {
        .hcan1 = &hcan1,
        .huart2 = &huart2,
        .hadc1 = &hadc1,
        .htim2 = &htim2
    };
    
    plt_callbacks_t callbacks = {
        .CAN_RxCallback = Can_MessageHandler,
        .UART_RxCallback = NULL
    };
    
    plt_SetHandlers(&handlers);
    plt_SetCallbacks(&callbacks);
    plt_CanInit(64);
    plt_UartInit(32);
    plt_AdcInit();
    plt_TimInit();
    
    // Main loop
    while (1) {
        plt_CanProcessRxMsgs();
        plt_UartProcessRxMsgs();
        
        // Send CAN message (clunky)
        can_message_t msg = {0};
        msg.id = 0x300;
        msg.data[0] = motorCommand;
        msg.data[1] = 0x01;
        plt_CanSendMsg(Can1, &msg);
        
        // Read ADC (no voltage conversion built-in)
        uint16_t raw = ADC1_AVG_Samples[0];
        float voltage = (raw / 4095.0) * 3.3;
        
        // PWM control (complex)
        plt_StartPWM(Tim2, TIM_CHANNEL_1, 25000, 30.0);
        
        HAL_Delay(50);
    }
}
#endif
