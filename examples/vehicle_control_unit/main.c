/**
 * @file main.c
 * @brief Complete example using the redesigned STM32 Platform API
 * 
 * This example demonstrates a real-world vehicle control unit that:
 * - Receives pedal position via CAN
 * - Reads throttle position from ADC
 * - Sends motor commands via CAN
 * - Logs data via UART
 * - Controls cooling fan PWM
 */

#include "main.h"
#include "stm32_platform.h"

/* ==================== Hardware Handles (from CubeMX) ==================== */
CAN_HandleTypeDef hcan1;
UART_HandleTypeDef huart2;
ADC_HandleTypeDef hadc1;
TIM_HandleTypeDef htim2;

/* ==================== Application State ==================== */
typedef struct {
    uint8_t pedalPosition;      // 0-100%
    uint16_t throttleRaw;       // ADC raw value
    float throttleVoltage;      // 0-5V
    float motorSpeed;           // RPM
    bool systemReady;
} VehicleState_t;

VehicleState_t vehicle = {0};

/* ==================== CAN Message Handlers ==================== */

// Called automatically when CAN message 0x180 arrives
void onPedalMessage(CANMessage_t* msg) {
    vehicle.pedalPosition = msg->data[0];
    
    // Log to UART
    UART.printf("Pedal: %d%%\n", vehicle.pedalPosition);
    
    // Update database
    Database.set("pedal.position", vehicle.pedalPosition);
}

// Called for CAN messages 0x200-0x20F (motor controller responses)
void onMotorResponse(CANMessage_t* msg) {
    // Parse motor speed from CAN data
    vehicle.motorSpeed = (msg->data[0] << 8) | msg->data[1];
    
    UART.printf("Motor RPM: %.0f\n", vehicle.motorSpeed);
    
    // Adjust cooling fan based on speed
    if (vehicle.motorSpeed > 5000) {
        PWM.setDutyCycle(&htim2, TIM_CHANNEL_1, 100.0);  // Fan 100%
    } else if (vehicle.motorSpeed > 3000) {
        PWM.setDutyCycle(&htim2, TIM_CHANNEL_1, 60.0);   // Fan 60%
    } else {
        PWM.setDutyCycle(&htim2, TIM_CHANNEL_1, 30.0);   // Fan 30%
    }
}

// Called when any unhandled CAN message arrives
void onUnknownCANMessage(CANMessage_t* msg) {
    UART.printf("Unknown CAN ID: 0x%03X\n", msg->id);
}

/* ==================== Application Functions ==================== */

void sendMotorCommand(void) {
    // Read throttle position from ADC
    vehicle.throttleRaw = ADC.read(ADC_CHANNEL_1);
    vehicle.throttleVoltage = ADC.readVoltage(ADC_CHANNEL_1);
    
    // Calculate motor command (0-100%)
    uint8_t motorCommand = (vehicle.throttleVoltage / 5.0) * 100;
    
    // Apply pedal position limit
    if (motorCommand > vehicle.pedalPosition) {
        motorCommand = vehicle.pedalPosition;
    }
    
    // Send motor command via CAN
    uint8_t data[8] = {
        motorCommand,           // Byte 0: Throttle command
        0x01,                   // Byte 1: Enable motor
        0x00, 0x00,            // Bytes 2-3: Reserved
        vehicle.pedalPosition,  // Byte 4: Pedal position
        0x00, 0x00, 0x00       // Bytes 5-7: Reserved
    };
    
    if (!CAN.send(0x300, data, 8)) {
        UART.println("ERROR: CAN send failed");
        
        // Check error details
        ErrorCode_t err = STM32.getLastError();
        UART.printf("Error code: %d - %s\n", err, STM32.getErrorString(err));
    }
}

void systemHealthCheck(void) {
    // Check CAN bus status
    if (!CAN.isReady()) {
        UART.println("WARNING: CAN bus not ready");
        vehicle.systemReady = false;
        return;
    }
    
    // Check if we've received recent pedal messages
    if (CAN.getLastMessageTime(0x180) > 1000) {  // >1 second old
        UART.println("WARNING: Pedal timeout");
        vehicle.systemReady = false;
        return;
    }
    
    // Check ADC readings are valid
    if (vehicle.throttleVoltage > 5.1) {
        UART.println("WARNING: Throttle sensor out of range");
        vehicle.systemReady = false;
        return;
    }
    
    vehicle.systemReady = true;
}

void printSystemStatus(void) {
    UART.println("========== System Status ==========");
    UART.printf("Platform Version: %s\n", STM32.version());
    UART.printf("System Ready: %s\n", vehicle.systemReady ? "YES" : "NO");
    UART.printf("Pedal Position: %d%%\n", vehicle.pedalPosition);
    UART.printf("Throttle ADC: %d (%.2fV)\n", vehicle.throttleRaw, vehicle.throttleVoltage);
    UART.printf("Motor Speed: %.0f RPM\n", vehicle.motorSpeed);
    UART.printf("CAN Messages: %d pending\n", CAN.available());
    UART.printf("CAN Error Count: %d\n", CAN.getErrorCount());
    UART.println("===================================\n");
}

/* ==================== Main Function ==================== */

int main(void) {
    /* MCU Configuration (generated by CubeMX) */
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_CAN1_Init();
    MX_USART2_UART_Init();
    MX_ADC1_Init();
    MX_TIM2_Init();
    
    /* ==================== Platform Initialization ==================== */
    
    // Initialize platform with all peripherals
    STM32.begin(&hcan1, &huart2, NULL, &hadc1, &htim2)
         ->onCAN(onUnknownCANMessage);  // Default CAN handler
    
    // Wait for platform ready
    HAL_Delay(100);
    
    /* ==================== Application Setup ==================== */
    
    // Configure UART for debugging
    UART.println("\n\n===================================");
    UART.println("Vehicle Control Unit v1.0.0");
    UART.printf("Platform: %s\n", STM32.version());
    UART.println("===================================\n");
    
    // Set up CAN message routing
    CAN.route(0x180, onPedalMessage);           // Pedal position
    CAN.routeRange(0x200, 0x20F, onMotorResponse);  // Motor responses
    
    // Configure CAN filters (optional - accept all by default)
    CAN.setFilter(0x180, 0x7FF);  // Only accept pedal message
    
    // Configure ADC
    ADC.setResolution(12);        // 12-bit resolution
    ADC.setReference(3.3);        // 3.3V reference
    ADC.calibrate();              // Calibrate ADC
    
    // Configure PWM for cooling fan
    PWM.setFrequency(&htim2, 25000);  // 25 kHz for fan
    PWM.start(&htim2, TIM_CHANNEL_1);
    PWM.setDutyCycle(&htim2, TIM_CHANNEL_1, 30.0);  // Start at 30%
    
    UART.println("System initialized successfully\n");
    
    /* ==================== Main Loop ==================== */
    
    uint32_t lastCommandTime = 0;
    uint32_t lastStatusTime = 0;
    uint32_t lastHealthCheck = 0;
    
    while (1) {
        // Process all platform messages (CAN, UART, etc.)
        // This calls your registered callbacks automatically
        STM32.process();
        
        // Send motor command every 50ms
        if (HAL_GetTick() - lastCommandTime >= 50) {
            lastCommandTime = HAL_GetTick();
            
            if (vehicle.systemReady) {
                sendMotorCommand();
            } else {
                // Safety: Send zero throttle if system not ready
                uint8_t safeData[8] = {0};
                CAN.send(0x300, safeData, 8);
            }
        }
        
        // Print status every 1 second
        if (HAL_GetTick() - lastStatusTime >= 1000) {
            lastStatusTime = HAL_GetTick();
            printSystemStatus();
        }
        
        // Health check every 100ms
        if (HAL_GetTick() - lastHealthCheck >= 100) {
            lastHealthCheck = HAL_GetTick();
            systemHealthCheck();
        }
        
        // Optional: Process UART commands
        if (UART.available() > 0) {
            char cmd = UART.read();
            
            switch (cmd) {
                case 's':
                    printSystemStatus();
                    break;
                    
                case 'r':
                    UART.println("Resetting system...");
                    NVIC_SystemReset();
                    break;
                    
                case 'c':
                    UART.printf("CAN Stats:\n");
                    UART.printf("  TX Count: %d\n", CAN.getTxCount());
                    UART.printf("  RX Count: %d\n", CAN.getRxCount());
                    UART.printf("  Errors: %d\n", CAN.getErrorCount());
                    break;
                    
                default:
                    UART.println("Unknown command. Commands: s=status, r=reset, c=can stats");
            }
        }
    }
}

/* ==================== System Configuration (CubeMX Generated) ==================== */

void SystemClock_Config(void) {
    // CubeMX generated code
}

void Error_Handler(void) {
    UART.println("FATAL ERROR: System halted");
    UART.printf("Error: %s\n", STM32.getErrorString(STM32.getLastError()));
    
    while (1) {
        // Blink error LED
        HAL_Delay(200);
    }
}

/* ==================== Comparison: Same App with Old API ==================== */

#ifdef OLD_API_EXAMPLE
/* This is what the same application looked like with the old API: */

void main_old_api(void) {
    // Setup handlers (verbose)
    handler_set_t handlers = {
        .hcan1 = &hcan1,
        .huart2 = &huart2,
        .hadc1 = &hadc1,
        .htim2 = &htim2
    };
    
    plt_callbacks_t callbacks = {
        .CAN_RxCallback = Can_MessageHandler,
        .UART_RxCallback = NULL
    };
    
    plt_SetHandlers(&handlers);
    plt_SetCallbacks(&callbacks);
    plt_CanInit(64);
    plt_UartInit(32);
    plt_AdcInit();
    plt_TimInit();
    
    // Main loop
    while (1) {
        plt_CanProcessRxMsgs();
        plt_UartProcessRxMsgs();
        
        // Send CAN message (clunky)
        can_message_t msg = {0};
        msg.id = 0x300;
        msg.data[0] = motorCommand;
        msg.data[1] = 0x01;
        plt_CanSendMsg(Can1, &msg);
        
        // Read ADC (no voltage conversion built-in)
        uint16_t raw = ADC1_AVG_Samples[0];
        float voltage = (raw / 4095.0) * 3.3;
        
        // PWM control (complex)
        plt_StartPWM(Tim2, TIM_CHANNEL_1, 25000, 30.0);
        
        HAL_Delay(50);
    }
}
#endif
